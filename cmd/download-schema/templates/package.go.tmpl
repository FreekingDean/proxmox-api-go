// File generated by proxmox json schema, DO NOT EDIT

package {{.Name}}

import (
  "context"
	{{- if .ImportURL }}
	"fmt"
	"encoding/json"
	"net/url"
	"strings"
  {{- if .Strconv }}
	"regexp"
  {{ end }}

	{{- end -}}
  {{- if .Util }}
  "github.com/FreekingDean/proxmox-api-go/internal/util"
  {{ end }}
)

{{ if .Enums }}
const (
	{{ range $name, $enums := .Enums }}
		{{- range $_, $val := $enums }}
	{{ $name }}_{{ $val | Enumify }} {{ $name }} = "{{ $val }}"
		{{- end }}
	{{ end }}
)

{{- range $name, $_ := .Enums }}
type {{ $name }} string
{{- end }}

{{- range $name, $_ := .Enums }}
func Ptr{{ $name }}(i {{ $name }}) *{{ $name }} {
	return &i
}
{{- end }}
{{ end }}

type HTTPClient interface {
	Do(context.Context, string, string, interface{}, interface{}) error
}

type Client struct {
	httpClient HTTPClient
}

func New(c HTTPClient) *Client {
	return &Client{
		httpClient: c,
	}
}

{{- define "type" -}}
{{- if eq .Type "struct" -}}
struct {
{{- range $_, $prop := .Properties }}
  {{$prop.Name}} {{template "type" $prop}} `url:"{{$prop.JSONName}}" json:"{{$prop.JSONName}}"` {{ if $prop.Description }}// {{ $prop.Description }}{{ end }}
{{- end}}
{{ if .OptionalProperties }}
// The following parameters are optional
{{- range $_, $prop := .OptionalProperties }}
  {{$prop.Name}} {{template "type" $prop}} `url:"{{$prop.JSONName}},omitempty" json:"{{$prop.JSONName}},omitempty"` {{ if $prop.Description }}// {{ $prop.Description }}{{ end }}
{{- end}}
{{- end }}
}
{{- else -}}
{{ if .Optional }}*{{ end }}{{.Type}}
{{- end}}
{{- end}}

{{ define "operation" }}

// {{.Operation}} {{.Description}}
func (c *Client) {{.Operation}}(ctx context.Context
{{- if .Request}}, req {{.Request.Type}}{{end -}}
  ) ({{ if .Response -}}{{.Response.Type}}, {{ end }}error) {
  {{ if .Response -}}
	var resp {{.Response.Type}}
  {{ end }}
  err := c.httpClient.Do(ctx, "{{.Path}}", "{{.Method}}", {{ if .Response }}&resp{{ else }}nil{{ end }}, {{if .Request}}req{{else}}nil{{end}})
  return {{ if .Response }}resp, {{ end }}err
}
{{ end }}


{{ range $t := .Types }}
{{ if $t.Description }}
// {{ $t.Description }}
{{ end -}}
type {{ $t.Name }} {{ template "type" $t }}
type _{{ $t.Name }} {{ $t.Name }}
{{ if $t.FormatArrayTypes  }}
func (t *{{ $t.Name }}) UnmarshalJSON(d []byte) error {
	tmp := _{{ $t.Name }}{}
	err := json.Unmarshal(d, &tmp)
	if err != nil {
		return err
	}
	*t = {{ $t.Name }}(tmp)
	rest := map[string]json.RawMessage{}
	err = json.Unmarshal(d, &rest)
	if err != nil {
		return err
	}
	for k, v := range rest {
		{{ range $_, $ft := $t.FormatArrayTypes }}
		if ok, err := regexp.MatchString("^{{ $ft.JSONName | TrimN }}[0-9]+$", k); ok {
			if t.{{ $ft.Name }} == nil {
				set := make({{ $ft.Type }})
				t.{{ $ft.Name }} = {{ if $ft.Optional }}&{{ end }}set
			}
			var newVal {{ $ft.ElemType.Type | TrimPrefArr }}
			err = json.Unmarshal(v, &newVal)
			if err != nil {
				return err
			}
			({{ if $ft.Optional }}*{{ end }}t.{{ $ft.Name }})[k] = &newVal
		} else if err != nil {
			return err
		}
		{{ end }}
	}
	return nil
}
{{ end }}
{{ if ne $t.Format ""}}
{{ if eq $t.Format "array" }}
func (t {{ $t.Name }}) EncodeValues(key string, v *url.Values) error {
	return util.EncodeArray(key, v, t)
}
{{ else }}
func (t {{ $t.Name }}) EncodeValues(key string, v *url.Values) error {
	return util.EncodeString(key, v, t, `{{ $t.Format }}`)
}

func (t *{{ $t.Name }}) UnmarshalJSON(d []byte) error {
	if len(d) == 0 || string(d) == `""` {
		return nil
	}
	cleaned := string(d)[1:len(d)-1]
	parts := strings.Split(cleaned, ",")
	values := map[string]string{}
  {{- if gt (len $t.Aliases)  0 }}
  aliases := map[string]string{}
  {{ range $_, $alias := $t.Aliases }}
  aliases["{{ $alias.Name }}"] = "{{ $alias.Alias }}"
  {{- end }}
  {{- end }}
	for _, p := range parts {
		kv := strings.Split(p, "=")
		if len(kv) > 2 {
			return fmt.Errorf("Wrong number of parts for kv pair '%s'", p)
		}
		if len(kv) == 1 {
			values["{{ $t.DefaultKey }}"] = kv[0]
			continue
		}
    {{- if gt (len $t.Aliases) 0 }}
    if len(kv) == 2 {
      if alias, ok := aliases[kv[0]]; ok {
        values[alias] = kv[1]
        values["{{ $t.DefaultKey }}"] = fmt.Sprintf(`"%s"`, kv[0])
      } else {
        values[kv[0]] = kv[1]
      }
    }
    {{- else }}
    values[kv[0]] = kv[1]
    {{- end }}
	}
	{{ range $_, $p := $t.Properties }}
	if v, ok := values["{{$p.JSONName}}"]; ok {
		{{ if eq $p.Type "string" }}
		v = fmt.Sprintf("\"%s\"", v)
		{{ end }}
		err := json.Unmarshal([]byte(v), &t.{{ $p.Name }})
		if err != nil {
			return err
		}
	}
	{{ end }}
	{{ range $_, $p := $t.OptionalProperties }}
	if v, ok := values["{{$p.JSONName}}"]; ok {
		{{ if or (eq $p.Type "string") $p.Enum}}
		v = fmt.Sprintf("\"%s\"", v)
		{{ end }}
		err := json.Unmarshal([]byte(v), &t.{{ $p.Name }})
		if err != nil {
			return err
		}
	}
	{{ end }}
	return nil
}
{{ end }}
{{ end }}
{{ end }}

{{ range $_, $method := .Methods }}
{{ template "operation" $method }}
{{ end }}
