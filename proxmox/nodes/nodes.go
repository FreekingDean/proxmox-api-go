// File generated by proxmox json schema, DO NOT EDIT

package nodes

import (
	"context"
)

type HTTPClient interface {
	Do(context.Context, string, string, interface{}, interface{}) error
}

type Client struct {
	httpClient HTTPClient
}

func New(c HTTPClient) *Client {
	return &Client{
		httpClient: c,
	}
}

type IndexResponse []*struct {
	Node   string `url:"node",json:"node"`     // The cluster node name.
	Status string `url:"status",json:"status"` // Node status.

	// The following parameters are optional
	Cpu            *float64 `url:"cpu,omitempty",json:"cpu,omitempty"`                         // CPU utilization.
	Level          *string  `url:"level,omitempty",json:"level,omitempty"`                     // Support level.
	Maxcpu         *int     `url:"maxcpu,omitempty",json:"maxcpu,omitempty"`                   // Number of available CPUs.
	Maxmem         *int     `url:"maxmem,omitempty",json:"maxmem,omitempty"`                   // Number of available memory in bytes.
	Mem            *int     `url:"mem,omitempty",json:"mem,omitempty"`                         // Used memory in bytes.
	SslFingerprint *string  `url:"ssl_fingerprint,omitempty",json:"ssl_fingerprint,omitempty"` // The SSL fingerprint for the node certificate.
	Uptime         *int     `url:"uptime,omitempty",json:"uptime,omitempty"`                   // Node uptime in seconds.
}

// Index Cluster node index.
func (c *Client) Index(ctx context.Context) (*IndexResponse, error) {
	var resp *IndexResponse

	err := c.httpClient.Do(ctx, "/nodes", "GET", &resp, nil)
	return resp, err
}

type FindRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type FindResponse []*map[string]interface{}

// Find Node index.
func (c *Client) Find(ctx context.Context, req *FindRequest) (*FindResponse, error) {
	var resp *FindResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}", "GET", &resp, req)
	return resp, err
}

type GetSubscriptionRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type GetSubscriptionResponse map[string]interface{}

// GetSubscription Read subscription info.
func (c *Client) GetSubscription(ctx context.Context, req *GetSubscriptionRequest) (*GetSubscriptionResponse, error) {
	var resp *GetSubscriptionResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/subscription", "GET", &resp, req)
	return resp, err
}

type UpdateSubscriptionRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Force *bool `url:"force,omitempty",json:"force,omitempty"` // Always connect to server, even if we have up to date info inside local cache.
}

type UpdateSubscriptionResponse map[string]interface{}

// UpdateSubscription Update subscription info.
func (c *Client) UpdateSubscription(ctx context.Context, req *UpdateSubscriptionRequest) (*UpdateSubscriptionResponse, error) {
	var resp *UpdateSubscriptionResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/subscription", "POST", &resp, req)
	return resp, err
}

type SetSubscriptionRequest struct {
	Key  string `url:"key",json:"key"`   // Proxmox VE subscription key
	Node string `url:"node",json:"node"` // The cluster node name.

}

type SetSubscriptionResponse map[string]interface{}

// SetSubscription Set subscription key.
func (c *Client) SetSubscription(ctx context.Context, req *SetSubscriptionRequest) (*SetSubscriptionResponse, error) {
	var resp *SetSubscriptionResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/subscription", "PUT", &resp, req)
	return resp, err
}

type DeleteSubscriptionRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type DeleteSubscriptionResponse map[string]interface{}

// DeleteSubscription Delete subscription key of this node.
func (c *Client) DeleteSubscription(ctx context.Context, req *DeleteSubscriptionRequest) (*DeleteSubscriptionResponse, error) {
	var resp *DeleteSubscriptionResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/subscription", "DELETE", &resp, req)
	return resp, err
}

type GetConfigRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Property *string `url:"property,omitempty",json:"property,omitempty"` // Return only a specific property from the node configuration.
}

type GetConfigResponse struct {

	// The following parameters are optional
	Acme                *string `url:"acme,omitempty",json:"acme,omitempty"`                                   // Node specific ACME settings.
	Acmedomainn         *string `url:"acmedomain[n],omitempty",json:"acmedomain[n],omitempty"`                 // ACME domain and validation plugin
	Description         *string `url:"description,omitempty",json:"description,omitempty"`                     // Description for the Node. Shown in the web-interface node notes panel. This is saved as comment inside the configuration file.
	Digest              *string `url:"digest,omitempty",json:"digest,omitempty"`                               // Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
	StartallOnbootDelay *int    `url:"startall-onboot-delay,omitempty",json:"startall-onboot-delay,omitempty"` // Initial delay in seconds, before starting all the Virtual Guests with on-boot enabled.
	Wakeonlan           *string `url:"wakeonlan,omitempty",json:"wakeonlan,omitempty"`                         // MAC address for wake on LAN
}

// GetConfig Get node configuration options.
func (c *Client) GetConfig(ctx context.Context, req *GetConfigRequest) (*GetConfigResponse, error) {
	var resp *GetConfigResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/config", "GET", &resp, req)
	return resp, err
}

type SetOptionsConfigRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Acme                *string `url:"acme,omitempty",json:"acme,omitempty"`                                   // Node specific ACME settings.
	Acmedomainn         *string `url:"acmedomain[n],omitempty",json:"acmedomain[n],omitempty"`                 // ACME domain and validation plugin
	Delete              *string `url:"delete,omitempty",json:"delete,omitempty"`                               // A list of settings you want to delete.
	Description         *string `url:"description,omitempty",json:"description,omitempty"`                     // Description for the Node. Shown in the web-interface node notes panel. This is saved as comment inside the configuration file.
	Digest              *string `url:"digest,omitempty",json:"digest,omitempty"`                               // Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
	StartallOnbootDelay *int    `url:"startall-onboot-delay,omitempty",json:"startall-onboot-delay,omitempty"` // Initial delay in seconds, before starting all the Virtual Guests with on-boot enabled.
	Wakeonlan           *string `url:"wakeonlan,omitempty",json:"wakeonlan,omitempty"`                         // MAC address for wake on LAN
}

type SetOptionsConfigResponse map[string]interface{}

// SetOptionsConfig Set node configuration options.
func (c *Client) SetOptionsConfig(ctx context.Context, req *SetOptionsConfigRequest) (*SetOptionsConfigResponse, error) {
	var resp *SetOptionsConfigResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/config", "PUT", &resp, req)
	return resp, err
}

type VersionRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type VersionResponse struct {
	Release string `url:"release",json:"release"` // The current installed Proxmox VE Release
	Repoid  string `url:"repoid",json:"repoid"`   // The short git commit hash ID from which this version was build
	Version string `url:"version",json:"version"` // The current installed pve-manager package version

}

// Version API version details
func (c *Client) Version(ctx context.Context, req *VersionRequest) (*VersionResponse, error) {
	var resp *VersionResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/version", "GET", &resp, req)
	return resp, err
}

type StatusRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type StatusResponse map[string]interface{}

// Status Read node status
func (c *Client) Status(ctx context.Context, req *StatusRequest) (*StatusResponse, error) {
	var resp *StatusResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/status", "GET", &resp, req)
	return resp, err
}

type NodeCmdStatusRequest struct {
	Command string `url:"command",json:"command"` // Specify the command.
	Node    string `url:"node",json:"node"`       // The cluster node name.

}

type NodeCmdStatusResponse map[string]interface{}

// NodeCmdStatus Reboot or shutdown a node.
func (c *Client) NodeCmdStatus(ctx context.Context, req *NodeCmdStatusRequest) (*NodeCmdStatusResponse, error) {
	var resp *NodeCmdStatusResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/status", "POST", &resp, req)
	return resp, err
}

type NetstatRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type NetstatResponse []*map[string]interface{}

// Netstat Read tap/vm network device interface counters
func (c *Client) Netstat(ctx context.Context, req *NetstatRequest) (*NetstatResponse, error) {
	var resp *NetstatResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/netstat", "GET", &resp, req)
	return resp, err
}

type ExecuteRequest struct {
	Commands string `url:"commands",json:"commands"` // JSON encoded array of commands.
	Node     string `url:"node",json:"node"`         // The cluster node name.

}

type ExecuteResponse []*map[string]interface{}

// Execute Execute multiple commands in order.
func (c *Client) Execute(ctx context.Context, req *ExecuteRequest) (*ExecuteResponse, error) {
	var resp *ExecuteResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/execute", "POST", &resp, req)
	return resp, err
}

type WakeonlanRequest struct {
	Node string `url:"node",json:"node"` // target node for wake on LAN packet

}

type WakeonlanResponse string

// Wakeonlan Try to wake a node via 'wake on LAN' network packet.
func (c *Client) Wakeonlan(ctx context.Context, req *WakeonlanRequest) (*WakeonlanResponse, error) {
	var resp *WakeonlanResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/wakeonlan", "POST", &resp, req)
	return resp, err
}

type RrdRequest struct {
	Ds        string `url:"ds",json:"ds"`               // The list of datasources you want to display.
	Node      string `url:"node",json:"node"`           // The cluster node name.
	Timeframe string `url:"timeframe",json:"timeframe"` // Specify the time frame you are interested in.

	// The following parameters are optional
	Cf *string `url:"cf,omitempty",json:"cf,omitempty"` // The RRD consolidation function
}

type RrdResponse struct {
	Filename string `url:"filename",json:"filename"`
}

// Rrd Read node RRD statistics (returns PNG)
func (c *Client) Rrd(ctx context.Context, req *RrdRequest) (*RrdResponse, error) {
	var resp *RrdResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/rrd", "GET", &resp, req)
	return resp, err
}

type RrddataRequest struct {
	Node      string `url:"node",json:"node"`           // The cluster node name.
	Timeframe string `url:"timeframe",json:"timeframe"` // Specify the time frame you are interested in.

	// The following parameters are optional
	Cf *string `url:"cf,omitempty",json:"cf,omitempty"` // The RRD consolidation function
}

type RrddataResponse []*map[string]interface{}

// Rrddata Read node RRD statistics
func (c *Client) Rrddata(ctx context.Context, req *RrddataRequest) (*RrddataResponse, error) {
	var resp *RrddataResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/rrddata", "GET", &resp, req)
	return resp, err
}

type SyslogRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Limit   *int    `url:"limit,omitempty",json:"limit,omitempty"`
	Service *string `url:"service,omitempty",json:"service,omitempty"` // Service ID
	Since   *string `url:"since,omitempty",json:"since,omitempty"`     // Display all log since this date-time string.
	Start   *int    `url:"start,omitempty",json:"start,omitempty"`
	Until   *string `url:"until,omitempty",json:"until,omitempty"` // Display all log until this date-time string.
}

type SyslogResponse []*struct {
	N int    `url:"n",json:"n"` // Line number
	T string `url:"t",json:"t"` // Line text

}

// Syslog Read system log
func (c *Client) Syslog(ctx context.Context, req *SyslogRequest) (*SyslogResponse, error) {
	var resp *SyslogResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/syslog", "GET", &resp, req)
	return resp, err
}

type JournalRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Endcursor   *string `url:"endcursor,omitempty",json:"endcursor,omitempty"`     // End before the given Cursor. Conflicts with 'until'
	Lastentries *int    `url:"lastentries,omitempty",json:"lastentries,omitempty"` // Limit to the last X lines. Conflicts with a range.
	Since       *int    `url:"since,omitempty",json:"since,omitempty"`             // Display all log since this UNIX epoch. Conflicts with 'startcursor'.
	Startcursor *string `url:"startcursor,omitempty",json:"startcursor,omitempty"` // Start after the given Cursor. Conflicts with 'since'
	Until       *int    `url:"until,omitempty",json:"until,omitempty"`             // Display all log until this UNIX epoch. Conflicts with 'endcursor'.
}

type JournalResponse []string

// Journal Read Journal
func (c *Client) Journal(ctx context.Context, req *JournalRequest) (*JournalResponse, error) {
	var resp *JournalResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/journal", "GET", &resp, req)
	return resp, err
}

type VncshellRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Cmd       *string `url:"cmd,omitempty",json:"cmd,omitempty"`             // Run specific command or default to login.
	CmdOpts   *string `url:"cmd-opts,omitempty",json:"cmd-opts,omitempty"`   // Add parameters to a command. Encoded as null terminated strings.
	Height    *int    `url:"height,omitempty",json:"height,omitempty"`       // sets the height of the console in pixels.
	Websocket *bool   `url:"websocket,omitempty",json:"websocket,omitempty"` // use websocket instead of standard vnc.
	Width     *int    `url:"width,omitempty",json:"width,omitempty"`         // sets the width of the console in pixels.
}

type VncshellResponse struct {
	Cert   string `url:"cert",json:"cert"`
	Port   int    `url:"port",json:"port"`
	Ticket string `url:"ticket",json:"ticket"`
	Upid   string `url:"upid",json:"upid"`
	User   string `url:"user",json:"user"`
}

// Vncshell Creates a VNC Shell proxy.
func (c *Client) Vncshell(ctx context.Context, req *VncshellRequest) (*VncshellResponse, error) {
	var resp *VncshellResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/vncshell", "POST", &resp, req)
	return resp, err
}

type TermproxyRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Cmd     *string `url:"cmd,omitempty",json:"cmd,omitempty"`           // Run specific command or default to login.
	CmdOpts *string `url:"cmd-opts,omitempty",json:"cmd-opts,omitempty"` // Add parameters to a command. Encoded as null terminated strings.
}

type TermproxyResponse struct {
	Port   int    `url:"port",json:"port"`
	Ticket string `url:"ticket",json:"ticket"`
	Upid   string `url:"upid",json:"upid"`
	User   string `url:"user",json:"user"`
}

// Termproxy Creates a VNC Shell proxy.
func (c *Client) Termproxy(ctx context.Context, req *TermproxyRequest) (*TermproxyResponse, error) {
	var resp *TermproxyResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/termproxy", "POST", &resp, req)
	return resp, err
}

type VncwebsocketRequest struct {
	Node      string `url:"node",json:"node"`           // The cluster node name.
	Port      int    `url:"port",json:"port"`           // Port number returned by previous vncproxy call.
	Vncticket string `url:"vncticket",json:"vncticket"` // Ticket from previous call to vncproxy.

}

type VncwebsocketResponse struct {
	Port string `url:"port",json:"port"`
}

// Vncwebsocket Opens a websocket for VNC traffic.
func (c *Client) Vncwebsocket(ctx context.Context, req *VncwebsocketRequest) (*VncwebsocketResponse, error) {
	var resp *VncwebsocketResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/vncwebsocket", "GET", &resp, req)
	return resp, err
}

type SpiceshellRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Cmd     *string `url:"cmd,omitempty",json:"cmd,omitempty"`           // Run specific command or default to login.
	CmdOpts *string `url:"cmd-opts,omitempty",json:"cmd-opts,omitempty"` // Add parameters to a command. Encoded as null terminated strings.
	Proxy   *string `url:"proxy,omitempty",json:"proxy,omitempty"`       // SPICE proxy server. This can be used by the client to specify the proxy server. All nodes in a cluster runs 'spiceproxy', so it is up to the client to choose one. By default, we return the node where the VM is currently running. As reasonable setting is to use same node you use to connect to the API (This is window.location.hostname for the JS GUI).
}

type SpiceshellResponse struct {
	Host     string `url:"host",json:"host"`
	Password string `url:"password",json:"password"`
	Proxy    string `url:"proxy",json:"proxy"`
	TlsPort  int    `url:"tls-port",json:"tls-port"`
	Type     string `url:"type",json:"type"`
}

// Spiceshell Creates a SPICE shell.
func (c *Client) Spiceshell(ctx context.Context, req *SpiceshellRequest) (*SpiceshellResponse, error) {
	var resp *SpiceshellResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/spiceshell", "POST", &resp, req)
	return resp, err
}

type DnsRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type DnsResponse struct {

	// The following parameters are optional
	Dns1   *string `url:"dns1,omitempty",json:"dns1,omitempty"`     // First name server IP address.
	Dns2   *string `url:"dns2,omitempty",json:"dns2,omitempty"`     // Second name server IP address.
	Dns3   *string `url:"dns3,omitempty",json:"dns3,omitempty"`     // Third name server IP address.
	Search *string `url:"search,omitempty",json:"search,omitempty"` // Search domain for host-name lookup.
}

// Dns Read DNS settings.
func (c *Client) Dns(ctx context.Context, req *DnsRequest) (*DnsResponse, error) {
	var resp *DnsResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/dns", "GET", &resp, req)
	return resp, err
}

type UpdateDnsRequest struct {
	Node   string `url:"node",json:"node"`     // The cluster node name.
	Search string `url:"search",json:"search"` // Search domain for host-name lookup.

	// The following parameters are optional
	Dns1 *string `url:"dns1,omitempty",json:"dns1,omitempty"` // First name server IP address.
	Dns2 *string `url:"dns2,omitempty",json:"dns2,omitempty"` // Second name server IP address.
	Dns3 *string `url:"dns3,omitempty",json:"dns3,omitempty"` // Third name server IP address.
}

type UpdateDnsResponse map[string]interface{}

// UpdateDns Write DNS settings.
func (c *Client) UpdateDns(ctx context.Context, req *UpdateDnsRequest) (*UpdateDnsResponse, error) {
	var resp *UpdateDnsResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/dns", "PUT", &resp, req)
	return resp, err
}

type TimeRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type TimeResponse struct {
	Localtime int    `url:"localtime",json:"localtime"` // Seconds since 1970-01-01 00:00:00 (local time)
	Time      int    `url:"time",json:"time"`           // Seconds since 1970-01-01 00:00:00 UTC.
	Timezone  string `url:"timezone",json:"timezone"`   // Time zone

}

// Time Read server time and time zone settings.
func (c *Client) Time(ctx context.Context, req *TimeRequest) (*TimeResponse, error) {
	var resp *TimeResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/time", "GET", &resp, req)
	return resp, err
}

type SetTimezoneTimeRequest struct {
	Node     string `url:"node",json:"node"`         // The cluster node name.
	Timezone string `url:"timezone",json:"timezone"` // Time zone. The file '/usr/share/zoneinfo/zone.tab' contains the list of valid names.

}

type SetTimezoneTimeResponse map[string]interface{}

// SetTimezoneTime Set time zone.
func (c *Client) SetTimezoneTime(ctx context.Context, req *SetTimezoneTimeRequest) (*SetTimezoneTimeResponse, error) {
	var resp *SetTimezoneTimeResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/time", "PUT", &resp, req)
	return resp, err
}

type AplinfoRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type AplinfoResponse []*map[string]interface{}

// Aplinfo Get list of appliances.
func (c *Client) Aplinfo(ctx context.Context, req *AplinfoRequest) (*AplinfoResponse, error) {
	var resp *AplinfoResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/aplinfo", "GET", &resp, req)
	return resp, err
}

type AplDownloadAplinfoRequest struct {
	Node     string `url:"node",json:"node"`         // The cluster node name.
	Storage  string `url:"storage",json:"storage"`   // The storage where the template will be stored
	Template string `url:"template",json:"template"` // The template which will downloaded

}

type AplDownloadAplinfoResponse string

// AplDownloadAplinfo Download appliance templates.
func (c *Client) AplDownloadAplinfo(ctx context.Context, req *AplDownloadAplinfoRequest) (*AplDownloadAplinfoResponse, error) {
	var resp *AplDownloadAplinfoResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/aplinfo", "POST", &resp, req)
	return resp, err
}

type QueryUrlMetadataRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.
	Url  string `url:"url",json:"url"`   // The URL to query the metadata from.

	// The following parameters are optional
	VerifyCertificates *bool `url:"verify-certificates,omitempty",json:"verify-certificates,omitempty"` // If false, no SSL/TLS certificates will be verified.
}

type QueryUrlMetadataResponse struct {

	// The following parameters are optional
	Filename *string `url:"filename,omitempty",json:"filename,omitempty"`
	Mimetype *string `url:"mimetype,omitempty",json:"mimetype,omitempty"`
	Size     *int    `url:"size,omitempty",json:"size,omitempty"`
}

// QueryUrlMetadata Query metadata of an URL: file size, file name and mime type.
func (c *Client) QueryUrlMetadata(ctx context.Context, req *QueryUrlMetadataRequest) (*QueryUrlMetadataResponse, error) {
	var resp *QueryUrlMetadataResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/query-url-metadata", "GET", &resp, req)
	return resp, err
}

type ReportRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type ReportResponse string

// Report Gather various systems information about a node
func (c *Client) Report(ctx context.Context, req *ReportRequest) (*ReportResponse, error) {
	var resp *ReportResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/report", "GET", &resp, req)
	return resp, err
}

type StartallRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Force *bool   `url:"force,omitempty",json:"force,omitempty"` // Issue start command even if virtual guest have 'onboot' not set or set to off.
	Vms   *string `url:"vms,omitempty",json:"vms,omitempty"`     // Only consider guests from this comma separated list of VMIDs.
}

type StartallResponse string

// Startall Start all VMs and containers located on this node (by default only those with onboot=1).
func (c *Client) Startall(ctx context.Context, req *StartallRequest) (*StartallResponse, error) {
	var resp *StartallResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/startall", "POST", &resp, req)
	return resp, err
}

type StopallRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Vms *string `url:"vms,omitempty",json:"vms,omitempty"` // Only consider Guests with these IDs.
}

type StopallResponse string

// Stopall Stop all VMs and Containers.
func (c *Client) Stopall(ctx context.Context, req *StopallRequest) (*StopallResponse, error) {
	var resp *StopallResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/stopall", "POST", &resp, req)
	return resp, err
}

type MigrateallRequest struct {
	Node   string `url:"node",json:"node"`     // The cluster node name.
	Target string `url:"target",json:"target"` // Target node.

	// The following parameters are optional
	Maxworkers     *int    `url:"maxworkers,omitempty",json:"maxworkers,omitempty"`             // Maximal number of parallel migration job. If not set use 'max_workers' from datacenter.cfg, one of both must be set!
	Vms            *string `url:"vms,omitempty",json:"vms,omitempty"`                           // Only consider Guests with these IDs.
	WithLocalDisks *bool   `url:"with-local-disks,omitempty",json:"with-local-disks,omitempty"` // Enable live storage migration for local disk
}

type MigrateallResponse string

// Migrateall Migrate all VMs and Containers.
func (c *Client) Migrateall(ctx context.Context, req *MigrateallRequest) (*MigrateallResponse, error) {
	var resp *MigrateallResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/migrateall", "POST", &resp, req)
	return resp, err
}

type GetEtcHostsRequest struct {
	Node string `url:"node",json:"node"` // The cluster node name.

}

type GetEtcHostsResponse struct {
	Data string `url:"data",json:"data"` // The content of /etc/hosts.

	// The following parameters are optional
	Digest *string `url:"digest,omitempty",json:"digest,omitempty"` // Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
}

// GetEtcHosts Get the content of /etc/hosts.
func (c *Client) GetEtcHosts(ctx context.Context, req *GetEtcHostsRequest) (*GetEtcHostsResponse, error) {
	var resp *GetEtcHostsResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/hosts", "GET", &resp, req)
	return resp, err
}

type WriteEtcHostsRequest struct {
	Data string `url:"data",json:"data"` // The target content of /etc/hosts.
	Node string `url:"node",json:"node"` // The cluster node name.

	// The following parameters are optional
	Digest *string `url:"digest,omitempty",json:"digest,omitempty"` // Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
}

type WriteEtcHostsResponse map[string]interface{}

// WriteEtcHosts Write /etc/hosts.
func (c *Client) WriteEtcHosts(ctx context.Context, req *WriteEtcHostsRequest) (*WriteEtcHostsResponse, error) {
	var resp *WriteEtcHostsResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/hosts", "POST", &resp, req)
	return resp, err
}
