// File generated by proxmox json schema, DO NOT EDIT

package pool

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/FreekingDean/proxmox-api-go/internal/util"
	"net/url"
	"strings"
)

const (
	Application_RBD    Application = "rbd"
	Application_CEPHFS Application = "cephfs"
	Application_RGW    Application = "rgw"

	PgAutoscaleMode_ON   PgAutoscaleMode = "on"
	PgAutoscaleMode_OFF  PgAutoscaleMode = "off"
	PgAutoscaleMode_WARN PgAutoscaleMode = "warn"

	Type_REPLICATED Type = "replicated"
	Type_ERASURE    Type = "erasure"
	Type_UNKNOWN    Type = "unknown"
)

type Application string
type PgAutoscaleMode string
type Type string

func PtrApplication(i Application) *Application {
	return &i
}
func PtrPgAutoscaleMode(i PgAutoscaleMode) *PgAutoscaleMode {
	return &i
}
func PtrType(i Type) *Type {
	return &i
}

type HTTPClient interface {
	Do(context.Context, string, string, interface{}, interface{}) error
}

type Client struct {
	httpClient HTTPClient
}

func New(c HTTPClient) *Client {
	return &Client{
		httpClient: c,
	}
}

type IndexRequest struct {
	Node string `url:"node" json:"node"` // The cluster node name.

}
type _IndexRequest IndexRequest

type IndexResponse struct {
	BytesUsed     int     `url:"bytes_used" json:"bytes_used"`
	CrushRule     int     `url:"crush_rule" json:"crush_rule"`
	CrushRuleName string  `url:"crush_rule_name" json:"crush_rule_name"`
	MinSize       int     `url:"min_size" json:"min_size"`
	PercentUsed   float64 `url:"percent_used" json:"percent_used"`
	PgNum         int     `url:"pg_num" json:"pg_num"`
	Pool          int     `url:"pool" json:"pool"`
	PoolName      string  `url:"pool_name" json:"pool_name"`
	Size          int     `url:"size" json:"size"`
	Type          Type    `url:"type" json:"type"`

	// The following parameters are optional
	ApplicationMetadata *map[string]interface{} `url:"application_metadata,omitempty" json:"application_metadata,omitempty"`
	AutoscaleStatus     *map[string]interface{} `url:"autoscale_status,omitempty" json:"autoscale_status,omitempty"`
	PgAutoscaleMode     *string                 `url:"pg_autoscale_mode,omitempty" json:"pg_autoscale_mode,omitempty"`
	PgNumFinal          *int                    `url:"pg_num_final,omitempty" json:"pg_num_final,omitempty"`
	PgNumMin            *int                    `url:"pg_num_min,omitempty" json:"pg_num_min,omitempty"`
	TargetSize          *int                    `url:"target_size,omitempty" json:"target_size,omitempty"`
	TargetSizeRatio     *float64                `url:"target_size_ratio,omitempty" json:"target_size_ratio,omitempty"`
}
type _IndexResponse IndexResponse

// Create an erasure coded pool for RBD with an accompaning replicated pool for metadata storage. With EC, the common ceph options 'size', 'min_size' and 'crush_rule' parameters will be applied to the metadata pool.
type ErasureCoding struct {
	K int `url:"k" json:"k"` // Number of data chunks. Will create an erasure coded pool plus a replicated pool for metadata.
	M int `url:"m" json:"m"` // Number of coding chunks. Will create an erasure coded pool plus a replicated pool for metadata.

	// The following parameters are optional
	DeviceClass   *string `url:"device-class,omitempty" json:"device-class,omitempty"`     // CRUSH device class. Will create an erasure coded pool plus a replicated pool for metadata.
	FailureDomain *string `url:"failure-domain,omitempty" json:"failure-domain,omitempty"` // CRUSH failure domain. Default is 'host'. Will create an erasure coded pool plus a replicated pool for metadata.
	Profile       *string `url:"profile,omitempty" json:"profile,omitempty"`               // Override the erasure code (EC) profile to use. Will create an erasure coded pool plus a replicated pool for metadata.
}
type _ErasureCoding ErasureCoding

func (t ErasureCoding) EncodeValues(key string, v *url.Values) error {
	return util.EncodeString(key, v, t, `k=<integer> ,m=<integer> [,device-class=<class>] [,failure-domain=<domain>] [,profile=<profile>]`)
}

func (t *ErasureCoding) UnmarshalJSON(d []byte) error {
	if len(d) == 0 || string(d) == `""` {
		return nil
	}
	cleaned := string(d)[1 : len(d)-1]
	parts := strings.Split(cleaned, ",")
	values := map[string]string{}
	for _, p := range parts {
		kv := strings.Split(p, "=")
		if len(kv) > 2 {
			return fmt.Errorf("Wrong number of parts for kv pair '%s'", p)
		}
		if len(kv) == 1 {
			values[""] = kv[0]
			continue
		}
	}

	if v, ok := values["k"]; ok {

		err := json.Unmarshal([]byte(v), &t.K)
		if err != nil {
			return err
		}
	}

	if v, ok := values["m"]; ok {

		err := json.Unmarshal([]byte(v), &t.M)
		if err != nil {
			return err
		}
	}

	if v, ok := values["device-class"]; ok {

		v = fmt.Sprintf("\"%s\"", v)

		err := json.Unmarshal([]byte(v), &t.DeviceClass)
		if err != nil {
			return err
		}
	}

	if v, ok := values["failure-domain"]; ok {

		v = fmt.Sprintf("\"%s\"", v)

		err := json.Unmarshal([]byte(v), &t.FailureDomain)
		if err != nil {
			return err
		}
	}

	if v, ok := values["profile"]; ok {

		v = fmt.Sprintf("\"%s\"", v)

		err := json.Unmarshal([]byte(v), &t.Profile)
		if err != nil {
			return err
		}
	}

	return nil
}

type CreateRequest struct {
	Name string `url:"name" json:"name"` // The name of the pool. It must be unique.
	Node string `url:"node" json:"node"` // The cluster node name.

	// The following parameters are optional
	AddStorages     *util.PVEBool    `url:"add_storages,omitempty" json:"add_storages,omitempty"`           // Configure VM and CT storage using the new pool.
	Application     *Application     `url:"application,omitempty" json:"application,omitempty"`             // The application of the pool.
	CrushRule       *string          `url:"crush_rule,omitempty" json:"crush_rule,omitempty"`               // The rule to use for mapping object placement in the cluster.
	ErasureCoding   *ErasureCoding   `url:"erasure-coding,omitempty" json:"erasure-coding,omitempty"`       // Create an erasure coded pool for RBD with an accompaning replicated pool for metadata storage. With EC, the common ceph options 'size', 'min_size' and 'crush_rule' parameters will be applied to the metadata pool.
	MinSize         *int             `url:"min_size,omitempty" json:"min_size,omitempty"`                   // Minimum number of replicas per object
	PgAutoscaleMode *PgAutoscaleMode `url:"pg_autoscale_mode,omitempty" json:"pg_autoscale_mode,omitempty"` // The automatic PG scaling mode of the pool.
	PgNum           *int             `url:"pg_num,omitempty" json:"pg_num,omitempty"`                       // Number of placement groups.
	PgNumMin        *int             `url:"pg_num_min,omitempty" json:"pg_num_min,omitempty"`               // Minimal number of placement groups.
	Size            *int             `url:"size,omitempty" json:"size,omitempty"`                           // Number of replicas per object
	TargetSize      *string          `url:"target_size,omitempty" json:"target_size,omitempty"`             // The estimated target size of the pool for the PG autoscaler.
	TargetSizeRatio *float64         `url:"target_size_ratio,omitempty" json:"target_size_ratio,omitempty"` // The estimated target ratio of the pool for the PG autoscaler.
}
type _CreateRequest CreateRequest

type FindRequest struct {
	Name string `url:"name" json:"name"` // The name of the pool.
	Node string `url:"node" json:"node"` // The cluster node name.

}
type _FindRequest FindRequest

type UpdateRequest struct {
	Name string `url:"name" json:"name"` // The name of the pool. It must be unique.
	Node string `url:"node" json:"node"` // The cluster node name.

	// The following parameters are optional
	Application     *Application     `url:"application,omitempty" json:"application,omitempty"`             // The application of the pool.
	CrushRule       *string          `url:"crush_rule,omitempty" json:"crush_rule,omitempty"`               // The rule to use for mapping object placement in the cluster.
	MinSize         *int             `url:"min_size,omitempty" json:"min_size,omitempty"`                   // Minimum number of replicas per object
	PgAutoscaleMode *PgAutoscaleMode `url:"pg_autoscale_mode,omitempty" json:"pg_autoscale_mode,omitempty"` // The automatic PG scaling mode of the pool.
	PgNum           *int             `url:"pg_num,omitempty" json:"pg_num,omitempty"`                       // Number of placement groups.
	PgNumMin        *int             `url:"pg_num_min,omitempty" json:"pg_num_min,omitempty"`               // Minimal number of placement groups.
	Size            *int             `url:"size,omitempty" json:"size,omitempty"`                           // Number of replicas per object
	TargetSize      *string          `url:"target_size,omitempty" json:"target_size,omitempty"`             // The estimated target size of the pool for the PG autoscaler.
	TargetSizeRatio *float64         `url:"target_size_ratio,omitempty" json:"target_size_ratio,omitempty"` // The estimated target ratio of the pool for the PG autoscaler.
}
type _UpdateRequest UpdateRequest

type DeleteRequest struct {
	Name string `url:"name" json:"name"` // The name of the pool. It must be unique.
	Node string `url:"node" json:"node"` // The cluster node name.

	// The following parameters are optional
	Force           *util.PVEBool `url:"force,omitempty" json:"force,omitempty"`                       // If true, destroys pool even if in use
	RemoveEcprofile *util.PVEBool `url:"remove_ecprofile,omitempty" json:"remove_ecprofile,omitempty"` // Remove the erasure code profile. Defaults to true, if applicable.
	RemoveStorages  *util.PVEBool `url:"remove_storages,omitempty" json:"remove_storages,omitempty"`   // Remove all pveceph-managed storages configured for this pool
}
type _DeleteRequest DeleteRequest

type GetpoolStatusRequest struct {
	Name string `url:"name" json:"name"` // The name of the pool. It must be unique.
	Node string `url:"node" json:"node"` // The cluster node name.

	// The following parameters are optional
	Verbose *util.PVEBool `url:"verbose,omitempty" json:"verbose,omitempty"` // If enabled, will display additional data(eg. statistics).
}
type _GetpoolStatusRequest GetpoolStatusRequest

type GetpoolStatusResponse struct {
	FastRead             util.PVEBool `url:"fast_read" json:"fast_read"`
	Hashpspool           util.PVEBool `url:"hashpspool" json:"hashpspool"`
	Id                   int          `url:"id" json:"id"`
	Name                 string       `url:"name" json:"name"` // The name of the pool. It must be unique.
	NodeepScrub          util.PVEBool `url:"nodeep-scrub" json:"nodeep-scrub"`
	Nodelete             util.PVEBool `url:"nodelete" json:"nodelete"`
	Nopgchange           util.PVEBool `url:"nopgchange" json:"nopgchange"`
	Noscrub              util.PVEBool `url:"noscrub" json:"noscrub"`
	Nosizechange         util.PVEBool `url:"nosizechange" json:"nosizechange"`
	PgpNum               int          `url:"pgp_num" json:"pgp_num"`
	UseGmtHitset         util.PVEBool `url:"use_gmt_hitset" json:"use_gmt_hitset"`
	WriteFadviseDontneed util.PVEBool `url:"write_fadvise_dontneed" json:"write_fadvise_dontneed"`

	// The following parameters are optional
	Application     *Application              `url:"application,omitempty" json:"application,omitempty"` // The application of the pool.
	ApplicationList *[]map[string]interface{} `url:"application_list,omitempty" json:"application_list,omitempty"`
	AutoscaleStatus *map[string]interface{}   `url:"autoscale_status,omitempty" json:"autoscale_status,omitempty"`
	CrushRule       *string                   `url:"crush_rule,omitempty" json:"crush_rule,omitempty"`               // The rule to use for mapping object placement in the cluster.
	MinSize         *int                      `url:"min_size,omitempty" json:"min_size,omitempty"`                   // Minimum number of replicas per object
	PgAutoscaleMode *PgAutoscaleMode          `url:"pg_autoscale_mode,omitempty" json:"pg_autoscale_mode,omitempty"` // The automatic PG scaling mode of the pool.
	PgNum           *int                      `url:"pg_num,omitempty" json:"pg_num,omitempty"`                       // Number of placement groups.
	PgNumMin        *int                      `url:"pg_num_min,omitempty" json:"pg_num_min,omitempty"`               // Minimal number of placement groups.
	Size            *int                      `url:"size,omitempty" json:"size,omitempty"`                           // Number of replicas per object
	Statistics      *map[string]interface{}   `url:"statistics,omitempty" json:"statistics,omitempty"`
	TargetSize      *string                   `url:"target_size,omitempty" json:"target_size,omitempty"`             // The estimated target size of the pool for the PG autoscaler.
	TargetSizeRatio *float64                  `url:"target_size_ratio,omitempty" json:"target_size_ratio,omitempty"` // The estimated target ratio of the pool for the PG autoscaler.
}
type _GetpoolStatusResponse GetpoolStatusResponse

// Index List all pools and their settings (which are settable by the POST/PUT endpoints).
func (c *Client) Index(ctx context.Context, req IndexRequest) ([]IndexResponse, error) {
	var resp []IndexResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool", "GET", &resp, req)
	return resp, err
}

// Create Create Ceph pool
func (c *Client) Create(ctx context.Context, req CreateRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool", "POST", &resp, req)
	return resp, err
}

// Find Pool index.
func (c *Client) Find(ctx context.Context, req FindRequest) ([]map[string]interface{}, error) {
	var resp []map[string]interface{}

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool/{name}", "GET", &resp, req)
	return resp, err
}

// Update Change POOL settings
func (c *Client) Update(ctx context.Context, req UpdateRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool/{name}", "PUT", &resp, req)
	return resp, err
}

// Delete Destroy pool
func (c *Client) Delete(ctx context.Context, req DeleteRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool/{name}", "DELETE", &resp, req)
	return resp, err
}

// GetpoolStatus Show the current pool status.
func (c *Client) GetpoolStatus(ctx context.Context, req GetpoolStatusRequest) (GetpoolStatusResponse, error) {
	var resp GetpoolStatusResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/ceph/pool/{name}/status", "GET", &resp, req)
	return resp, err
}
