// File generated by proxmox json schema, DO NOT EDIT

package status

import (
	"context"
)

type HTTPClient interface {
	Do(context.Context, string, string, interface{}, interface{}) error
}

type Client struct {
	httpClient HTTPClient
}

func New(c HTTPClient) *Client {
	return &Client{
		httpClient: c,
	}
}

type IndexRequest struct {
	Node string `url:"node",json:"node"`
	Vmid int    `url:"vmid",json:"vmid"`
}

type IndexResponse []*struct {
	Subdir string `url:"subdir",json:"subdir"`
}

// Index Directory index
func (c *Client) Index(ctx context.Context, req *IndexRequest) (*IndexResponse, error) {
	var resp *IndexResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status", "GET", &resp, req)
	return resp, err
}

type VmStatusCurrentRequest struct {
	Node string `url:"node",json:"node"`
	Vmid int    `url:"vmid",json:"vmid"`
}

type VmStatusCurrentResponse struct {
	Cpus           *float64               `url:"cpus,omitempty",json:"cpus,omitempty"`
	Ha             map[string]interface{} `url:"ha",json:"ha"`
	Maxmem         *int                   `url:"maxmem,omitempty",json:"maxmem,omitempty"`
	Qmpstatus      *string                `url:"qmpstatus,omitempty",json:"qmpstatus,omitempty"`
	Tags           *string                `url:"tags,omitempty",json:"tags,omitempty"`
	Maxdisk        *int                   `url:"maxdisk,omitempty",json:"maxdisk,omitempty"`
	Name           *string                `url:"name,omitempty",json:"name,omitempty"`
	Lock           *string                `url:"lock,omitempty",json:"lock,omitempty"`
	Pid            *int                   `url:"pid,omitempty",json:"pid,omitempty"`
	Status         string                 `url:"status",json:"status"`
	Vmid           int                    `url:"vmid",json:"vmid"`
	Agent          *bool                  `url:"agent,omitempty",json:"agent,omitempty"`
	RunningMachine *string                `url:"running-machine,omitempty",json:"running-machine,omitempty"`
	RunningQemu    *string                `url:"running-qemu,omitempty",json:"running-qemu,omitempty"`
	Spice          *bool                  `url:"spice,omitempty",json:"spice,omitempty"`
	Uptime         *int                   `url:"uptime,omitempty",json:"uptime,omitempty"`
}

// VmStatusCurrent Get virtual machine status.
func (c *Client) VmStatusCurrent(ctx context.Context, req *VmStatusCurrentRequest) (*VmStatusCurrentResponse, error) {
	var resp *VmStatusCurrentResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/current", "GET", &resp, req)
	return resp, err
}

type VmStartRequest struct {
	Migratedfrom     *string `url:"migratedfrom,omitempty",json:"migratedfrom,omitempty"`
	MigrationNetwork *string `url:"migration_network,omitempty",json:"migration_network,omitempty"`
	Node             string  `url:"node",json:"node"`
	Timeout          *int    `url:"timeout,omitempty",json:"timeout,omitempty"`
	Vmid             int     `url:"vmid",json:"vmid"`
	ForceCpu         *string `url:"force-cpu,omitempty",json:"force-cpu,omitempty"`
	Machine          *string `url:"machine,omitempty",json:"machine,omitempty"`
	MigrationType    *string `url:"migration_type,omitempty",json:"migration_type,omitempty"`
	Skiplock         *bool   `url:"skiplock,omitempty",json:"skiplock,omitempty"`
	Stateuri         *string `url:"stateuri,omitempty",json:"stateuri,omitempty"`
	Targetstorage    *string `url:"targetstorage,omitempty",json:"targetstorage,omitempty"`
}

type VmStartResponse string

// VmStart Start virtual machine.
func (c *Client) VmStart(ctx context.Context, req *VmStartRequest) (*VmStartResponse, error) {
	var resp *VmStartResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/start", "POST", &resp, req)
	return resp, err
}

type VmStopRequest struct {
	Skiplock     *bool   `url:"skiplock,omitempty",json:"skiplock,omitempty"`
	Timeout      *int    `url:"timeout,omitempty",json:"timeout,omitempty"`
	Vmid         int     `url:"vmid",json:"vmid"`
	Keepactive   *bool   `url:"keepActive,omitempty",json:"keepActive,omitempty"`
	Migratedfrom *string `url:"migratedfrom,omitempty",json:"migratedfrom,omitempty"`
	Node         string  `url:"node",json:"node"`
}

type VmStopResponse string

// VmStop Stop virtual machine. The qemu process will exit immediately. Thisis akin to pulling the power plug of a running computer and may damage the VM data
func (c *Client) VmStop(ctx context.Context, req *VmStopRequest) (*VmStopResponse, error) {
	var resp *VmStopResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/stop", "POST", &resp, req)
	return resp, err
}

type VmResetRequest struct {
	Node     string `url:"node",json:"node"`
	Skiplock *bool  `url:"skiplock,omitempty",json:"skiplock,omitempty"`
	Vmid     int    `url:"vmid",json:"vmid"`
}

type VmResetResponse string

// VmReset Reset virtual machine.
func (c *Client) VmReset(ctx context.Context, req *VmResetRequest) (*VmResetResponse, error) {
	var resp *VmResetResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/reset", "POST", &resp, req)
	return resp, err
}

type VmShutdownRequest struct {
	Forcestop  *bool  `url:"forceStop,omitempty",json:"forceStop,omitempty"`
	Keepactive *bool  `url:"keepActive,omitempty",json:"keepActive,omitempty"`
	Node       string `url:"node",json:"node"`
	Skiplock   *bool  `url:"skiplock,omitempty",json:"skiplock,omitempty"`
	Timeout    *int   `url:"timeout,omitempty",json:"timeout,omitempty"`
	Vmid       int    `url:"vmid",json:"vmid"`
}

type VmShutdownResponse string

// VmShutdown Shutdown virtual machine. This is similar to pressing the power button on a physical machine.This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.
func (c *Client) VmShutdown(ctx context.Context, req *VmShutdownRequest) (*VmShutdownResponse, error) {
	var resp *VmShutdownResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/shutdown", "POST", &resp, req)
	return resp, err
}

type VmRebootRequest struct {
	Node    string `url:"node",json:"node"`
	Timeout *int   `url:"timeout,omitempty",json:"timeout,omitempty"`
	Vmid    int    `url:"vmid",json:"vmid"`
}

type VmRebootResponse string

// VmReboot Reboot the VM by shutting it down, and starting it again. Applies pending changes.
func (c *Client) VmReboot(ctx context.Context, req *VmRebootRequest) (*VmRebootResponse, error) {
	var resp *VmRebootResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/reboot", "POST", &resp, req)
	return resp, err
}

type VmSuspendRequest struct {
	Statestorage *string `url:"statestorage,omitempty",json:"statestorage,omitempty"`
	Todisk       *bool   `url:"todisk,omitempty",json:"todisk,omitempty"`
	Vmid         int     `url:"vmid",json:"vmid"`
	Node         string  `url:"node",json:"node"`
	Skiplock     *bool   `url:"skiplock,omitempty",json:"skiplock,omitempty"`
}

type VmSuspendResponse string

// VmSuspend Suspend virtual machine.
func (c *Client) VmSuspend(ctx context.Context, req *VmSuspendRequest) (*VmSuspendResponse, error) {
	var resp *VmSuspendResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/suspend", "POST", &resp, req)
	return resp, err
}

type VmResumeRequest struct {
	Nocheck  *bool  `url:"nocheck,omitempty",json:"nocheck,omitempty"`
	Node     string `url:"node",json:"node"`
	Skiplock *bool  `url:"skiplock,omitempty",json:"skiplock,omitempty"`
	Vmid     int    `url:"vmid",json:"vmid"`
}

type VmResumeResponse string

// VmResume Resume virtual machine.
func (c *Client) VmResume(ctx context.Context, req *VmResumeRequest) (*VmResumeResponse, error) {
	var resp *VmResumeResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/qemu/{vmid}/status/resume", "POST", &resp, req)
	return resp, err
}
