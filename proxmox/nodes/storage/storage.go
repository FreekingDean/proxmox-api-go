// File generated by proxmox json schema, DO NOT EDIT

package storage

import (
	"context"
	"github.com/FreekingDean/proxmox-api-go/internal/util"
)

type HTTPClient interface {
	Do(context.Context, string, string, interface{}, interface{}) error
}

type Client struct {
	httpClient HTTPClient
}

func New(c HTTPClient) *Client {
	return &Client{
		httpClient: c,
	}
}

type IndexRequest struct {
	Node string `url:"node" json:"node"` // The cluster node name.

	// The following parameters are optional
	Content *string           `url:"content,omitempty" json:"content,omitempty"` // Only list stores which support this content type.
	Enabled *util.SpecialBool `url:"enabled,omitempty" json:"enabled,omitempty"` // Only list stores which are enabled (not disabled in config).
	Format  *util.SpecialBool `url:"format,omitempty" json:"format,omitempty"`   // Include information about formats
	Storage *string           `url:"storage,omitempty" json:"storage,omitempty"` // Only list status for specified storage
	Target  *string           `url:"target,omitempty" json:"target,omitempty"`   // If target is different to 'node', we only lists shared storages which content is accessible on this 'node' and the specified 'target' node.
}

type IndexResponse struct {
	Content string `url:"content" json:"content"` // Allowed storage content types.
	Storage string `url:"storage" json:"storage"` // The storage identifier.
	Type    string `url:"type" json:"type"`       // Storage type.

	// The following parameters are optional
	Active       *util.SpecialBool `url:"active,omitempty" json:"active,omitempty"`               // Set when storage is accessible.
	Avail        *int              `url:"avail,omitempty" json:"avail,omitempty"`                 // Available storage space in bytes.
	Enabled      *util.SpecialBool `url:"enabled,omitempty" json:"enabled,omitempty"`             // Set when storage is enabled (not disabled).
	Shared       *util.SpecialBool `url:"shared,omitempty" json:"shared,omitempty"`               // Shared flag from storage configuration.
	Total        *int              `url:"total,omitempty" json:"total,omitempty"`                 // Total storage space in bytes.
	Used         *int              `url:"used,omitempty" json:"used,omitempty"`                   // Used storage space in bytes.
	UsedFraction *float64          `url:"used_fraction,omitempty" json:"used_fraction,omitempty"` // Used fraction (used/total).
}

type FindRequest struct {
	Node    string `url:"node" json:"node"`       // The cluster node name.
	Storage string `url:"storage" json:"storage"` // The storage identifier.

}

type FindResponse struct {
	Subdir string `url:"subdir" json:"subdir"`
}

type DryrunPrunebackupsRequest struct {
	Node    string `url:"node" json:"node"`       // The cluster node name.
	Storage string `url:"storage" json:"storage"` // The storage identifier.

	// The following parameters are optional
	PruneBackups *string `url:"prune-backups,omitempty" json:"prune-backups,omitempty"` // Use these retention options instead of those from the storage configuration.
	Type         *string `url:"type,omitempty" json:"type,omitempty"`                   // Either 'qemu' or 'lxc'. Only consider backups for guests of this type.
	Vmid         *int    `url:"vmid,omitempty" json:"vmid,omitempty"`                   // Only consider backups for this guest.
}

type DryrunPrunebackupsResponse struct {
	Ctime int    `url:"ctime" json:"ctime"` // Creation time of the backup (seconds since the UNIX epoch).
	Mark  string `url:"mark" json:"mark"`   // Whether the backup would be kept or removed. Backups that are protected or don't use the standard naming scheme are not removed.
	Type  string `url:"type" json:"type"`   // One of 'qemu', 'lxc', 'openvz' or 'unknown'.
	Volid string `url:"volid" json:"volid"` // Backup volume ID.

	// The following parameters are optional
	Vmid *int `url:"vmid,omitempty" json:"vmid,omitempty"` // The VM the backup belongs to.
}

type DeletePrunebackupsRequest struct {
	Node    string `url:"node" json:"node"`       // The cluster node name.
	Storage string `url:"storage" json:"storage"` // The storage identifier.

	// The following parameters are optional
	PruneBackups *string `url:"prune-backups,omitempty" json:"prune-backups,omitempty"` // Use these retention options instead of those from the storage configuration.
	Type         *string `url:"type,omitempty" json:"type,omitempty"`                   // Either 'qemu' or 'lxc'. Only consider backups for guests of this type.
	Vmid         *int    `url:"vmid,omitempty" json:"vmid,omitempty"`                   // Only prune backups for this VM.
}

type ReadStatusRequest struct {
	Node    string `url:"node" json:"node"`       // The cluster node name.
	Storage string `url:"storage" json:"storage"` // The storage identifier.

}

type RrdRequest struct {
	Ds        string `url:"ds" json:"ds"`               // The list of datasources you want to display.
	Node      string `url:"node" json:"node"`           // The cluster node name.
	Storage   string `url:"storage" json:"storage"`     // The storage identifier.
	Timeframe string `url:"timeframe" json:"timeframe"` // Specify the time frame you are interested in.

	// The following parameters are optional
	Cf *string `url:"cf,omitempty" json:"cf,omitempty"` // The RRD consolidation function
}

type RrdResponse struct {
	Filename string `url:"filename" json:"filename"`
}

type RrddataRequest struct {
	Node      string `url:"node" json:"node"`           // The cluster node name.
	Storage   string `url:"storage" json:"storage"`     // The storage identifier.
	Timeframe string `url:"timeframe" json:"timeframe"` // Specify the time frame you are interested in.

	// The following parameters are optional
	Cf *string `url:"cf,omitempty" json:"cf,omitempty"` // The RRD consolidation function
}

type UploadRequest struct {
	Content  string `url:"content" json:"content"`   // Content type.
	Filename string `url:"filename" json:"filename"` // The name of the file to create. Caution: This will be normalized!
	Node     string `url:"node" json:"node"`         // The cluster node name.
	Storage  string `url:"storage" json:"storage"`   // The storage identifier.

	// The following parameters are optional
	Checksum          *string `url:"checksum,omitempty" json:"checksum,omitempty"`                     // The expected checksum of the file.
	ChecksumAlgorithm *string `url:"checksum-algorithm,omitempty" json:"checksum-algorithm,omitempty"` // The algorithm to calculate the checksum of the file.
	Tmpfilename       *string `url:"tmpfilename,omitempty" json:"tmpfilename,omitempty"`               // The source file name. This parameter is usually set by the REST handler. You can only overwrite it when connecting to the trusted port on localhost.
}

type DownloadUrlRequest struct {
	Content  string `url:"content" json:"content"`   // Content type.
	Filename string `url:"filename" json:"filename"` // The name of the file to create. Caution: This will be normalized!
	Node     string `url:"node" json:"node"`         // The cluster node name.
	Storage  string `url:"storage" json:"storage"`   // The storage identifier.
	Url      string `url:"url" json:"url"`           // The URL to download the file from.

	// The following parameters are optional
	Checksum           *string           `url:"checksum,omitempty" json:"checksum,omitempty"`                       // The expected checksum of the file.
	ChecksumAlgorithm  *string           `url:"checksum-algorithm,omitempty" json:"checksum-algorithm,omitempty"`   // The algorithm to calculate the checksum of the file.
	VerifyCertificates *util.SpecialBool `url:"verify-certificates,omitempty" json:"verify-certificates,omitempty"` // If false, no SSL/TLS certificates will be verified.
}

// Index Get status for all datastores.
func (c *Client) Index(ctx context.Context, req IndexRequest) ([]IndexResponse, error) {
	var resp []IndexResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage", "GET", &resp, req)
	return resp, err
}

// Find
func (c *Client) Find(ctx context.Context, req FindRequest) ([]FindResponse, error) {
	var resp []FindResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}", "GET", &resp, req)
	return resp, err
}

// DryrunPrunebackups Get prune information for backups. NOTE: this is only a preview and might not be what a subsequent prune call does if backups are removed/added in the meantime.
func (c *Client) DryrunPrunebackups(ctx context.Context, req DryrunPrunebackupsRequest) ([]DryrunPrunebackupsResponse, error) {
	var resp []DryrunPrunebackupsResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/prunebackups", "GET", &resp, req)
	return resp, err
}

// DeletePrunebackups Prune backups. Only those using the standard naming scheme are considered.
func (c *Client) DeletePrunebackups(ctx context.Context, req DeletePrunebackupsRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/prunebackups", "DELETE", &resp, req)
	return resp, err
}

// ReadStatus Read storage status.
func (c *Client) ReadStatus(ctx context.Context, req ReadStatusRequest) (map[string]interface{}, error) {
	var resp map[string]interface{}

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/status", "GET", &resp, req)
	return resp, err
}

// Rrd Read storage RRD statistics (returns PNG).
func (c *Client) Rrd(ctx context.Context, req RrdRequest) (RrdResponse, error) {
	var resp RrdResponse

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/rrd", "GET", &resp, req)
	return resp, err
}

// Rrddata Read storage RRD statistics.
func (c *Client) Rrddata(ctx context.Context, req RrddataRequest) ([]map[string]interface{}, error) {
	var resp []map[string]interface{}

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/rrddata", "GET", &resp, req)
	return resp, err
}

// Upload Upload templates and ISO images.
func (c *Client) Upload(ctx context.Context, req UploadRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/upload", "POST", &resp, req)
	return resp, err
}

// DownloadUrl Download templates and ISO images by using an URL.
func (c *Client) DownloadUrl(ctx context.Context, req DownloadUrlRequest) (string, error) {
	var resp string

	err := c.httpClient.Do(ctx, "/nodes/{node}/storage/{storage}/download-url", "POST", &resp, req)
	return resp, err
}
